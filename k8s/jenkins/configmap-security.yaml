apiVersion: v1
kind: ConfigMap
metadata:
  name: jenkins-security-config
  namespace: jenkins
data:
  01-security.groovy: |
    import hudson.security.FullControlOnceLoggedInAuthorizationStrategy
    import hudson.security.HudsonPrivateSecurityRealm
    import jenkins.model.Jenkins

    Jenkins instance = Jenkins.get()

    String adminUser = System.getenv("JENKINS_ADMIN_USER") ?: "ci-admin"
    String adminPassword = System.getenv("JENKINS_ADMIN_PASSWORD") ?: ""

    if (!adminPassword) {
        throw new IllegalStateException("JENKINS_ADMIN_PASSWORD environment variable must be provided")
    }

    HudsonPrivateSecurityRealm realm = instance.getSecurityRealm() instanceof HudsonPrivateSecurityRealm
        ? (HudsonPrivateSecurityRealm) instance.getSecurityRealm()
        : new HudsonPrivateSecurityRealm(false)

    if (realm.getUser(adminUser) == null) {
        realm.createAccount(adminUser, adminPassword)
    } else {
        println "Admin user '${adminUser}' already exists; leave existing password untouched."
    }
    instance.setSecurityRealm(realm)

    FullControlOnceLoggedInAuthorizationStrategy strategy = new FullControlOnceLoggedInAuthorizationStrategy()
    strategy.setAllowAnonymousRead(false)
    instance.setAuthorizationStrategy(strategy)

    instance.save()
  02-kubernetes-cloud.groovy: |
    import jenkins.model.Jenkins

    try {
        def instance = Jenkins.get()
        def cloudName = 'kubernetes'

        if (instance.pluginManager.getPlugin('kubernetes') == null) {
            println "Kubernetes plugin not installed; skipping cloud configuration"
            return
        }

        def serverUrl = 'https://kubernetes.default.svc.cluster.local'
        def namespace = System.getenv('POD_NAMESPACE') ?: 'jenkins'
        def jenkinsServiceName = System.getenv('JENKINS_SERVICE_NAME') ?: 'jenkins'
        def jenkinsHttpPort = System.getenv('JENKINS_SERVICE_PORT_HTTP') ?: '80'
        def jenkinsAgentPort = System.getenv('JENKINS_SERVICE_PORT_AGENT') ?: '50000'
        def jenkinsUrl = "http://${jenkinsServiceName}.${namespace}.svc.cluster.local:${jenkinsHttpPort}"
        def jenkinsTunnel = "${jenkinsServiceName}.${namespace}.svc.cluster.local:${jenkinsAgentPort}"

        def cloud = instance.clouds.getByName(cloudName)
        if (cloud == null) {
            cloud = new org.csanchez.jenkins.plugins.kubernetes.KubernetesCloud(cloudName)
            instance.clouds.add(cloud)
            println "Configured Kubernetes cloud '${cloudName}' for namespace '${namespace}'"
        } else {
            println "Kubernetes cloud '${cloudName}' already configured; applying desired settings"
        }

        cloud.setServerUrl(serverUrl)
        cloud.setNamespace(namespace)
        cloud.setSkipTlsVerify(true)
        cloud.setJenkinsUrl(jenkinsUrl)
        cloud.setJenkinsTunnel(jenkinsTunnel)
        cloud.setContainerCapStr('10')

        instance.save()
    } catch (Throwable t) {
        println "Failed to configure Kubernetes cloud: ${t.message}"
        t.printStackTrace()
    }
  03-smtp.groovy: |
    import hudson.plugins.emailext.ExtendedEmailPublisherDescriptor
    import hudson.tasks.Mailer
    import jenkins.model.Jenkins
    import jenkins.model.JenkinsLocationConfiguration

    try {
        def instance = Jenkins.get()

        def jenkinsUrl = System.getenv('JENKINS_URL') ?: 'http://jenkins.jenkins.svc.cluster.local:3000/'
        def adminEmail = System.getenv('JENKINS_ADMIN_EMAIL') ?: 'shivam.sharma.942533@gmail.com'
        def replyTo = System.getenv('SMTP_REPLYTO') ?: 'shivam.sharma.942533@gmail.com'
    def smtpHost = System.getenv('SMTP_HOST') ?: 'smtp.gmail.com'
    def smtpPort = System.getenv('SMTP_PORT') ?: '465'
    def smtpUser = System.getenv('SMTP_USER')
    def smtpPassword = System.getenv('SMTP_PASSWORD')

        def location = JenkinsLocationConfiguration.get()
        location.setUrl(jenkinsUrl)
        location.setAdminAddress(adminEmail)
        location.save()

        def mailer = instance.getDescriptorByType(Mailer.DescriptorImpl)
        mailer.setSmtpHost(smtpHost)
        mailer.setSmtpPort(smtpPort)
        mailer.setUseSsl(true)
        mailer.setUseTls(false)
        mailer.setSmtpAuth(smtpUser, smtpPassword)
        mailer.setReplyToAddress(replyTo)
        mailer.setCharset('UTF-8')
        mailer.save()

        def emailExt = instance.getDescriptorByType(ExtendedEmailPublisherDescriptor)
        if (emailExt) {
            try {
                emailExt.setSmtpServer(smtpHost)
                emailExt.setSmtpPort(smtpPort)
                emailExt.setUseSsl(true)
                emailExt.setSmtpAuth(smtpUser, smtpPassword)
                emailExt.setCharset('UTF-8')
                emailExt.setDefaultReplyTo(replyTo)
                emailExt.setAdvProperties('mail.smtp.starttls.enable=false')
                emailExt.save()
                println "Configured Email-ext plugin for host '${smtpHost}:${smtpPort}'"
            } catch (Throwable et) {
                println "Failed to configure Email-ext plugin: ${et.message}"
                et.printStackTrace()
            }
        } else {
            println 'Email-ext plugin not installed; skipping extended email configuration'
        }

    println "Configured SMTP server '${smtpHost}:${smtpPort}' with reply-to '${replyTo}'"
    } catch (Throwable t) {
        println "Failed to configure SMTP server: ${t.message}"
        t.printStackTrace()
    }
  04-pipeline-job.groovy: |
    import jenkins.model.Jenkins
    import org.jenkinsci.plugins.workflow.multibranch.WorkflowMultiBranchProject
    import jenkins.branch.BranchSource
    import org.jenkinsci.plugins.github_branch_source.GitHubSCMSource

    try {
        def instance = Jenkins.getInstance()
        def jobName = 'demo-app-pipeline'

        def job = instance.getItem(jobName)
        
        if (job == null) {
            println "Creating Multibranch Pipeline job: ${jobName}"
            
            def project = instance.createProject(WorkflowMultiBranchProject, jobName)
            
            def scmSource = new GitHubSCMSource('Sourabh-Tomar', 'demo-app')
            def branchSource = new BranchSource(scmSource)
            
            project.getSourcesList().add(branchSource)
            project.save()
            
            println "Created Multibranch Pipeline job: ${jobName}"
        } else {
            println "Pipeline job '${jobName}' already exists"
        }
        
        instance.save()
    } catch (Throwable t) {
        println "Failed to create pipeline job: ${t.message}"
        t.printStackTrace()
    }
